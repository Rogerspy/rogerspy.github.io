<h1>Numpy基础（三）利用数组进行数据处理</h1>

[TOC]

# 1. `meshgrid`函数

`meshgrid`函数可以将两个一维数组转换成两个二维数组，对应于两个数组中的所有（x, y）对。

```python {cmd=true output="markdown" matplotlib=true}
import numpy as np
import matplotlib.pyplot as plt

# 创建一维数组
points = np.arange(-5, 5, 0.01)

# 将一维数组meshgrid成两个二维数组
x, y = np.meshgrid(points, points)
#print('x array: \n', x)
#print('y array: \n', y)

#> x array:
#>  [[-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
#>  [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
#>  [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
#>  ...
#>  [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
#>  [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
#>  [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]]
#> y array:
#>  [[-5.   -5.   -5.   ... -5.   -5.   -5.  ]
#>  [-4.99 -4.99 -4.99 ... -4.99 -4.99 -4.99]
#>  [-4.98 -4.98 -4.98 ... -4.98 -4.98 -4.98]
#>  ...
#>  [ 4.97  4.97  4.97 ...  4.97  4.97  4.97]
#>  [ 4.98  4.98  4.98 ...  4.98  4.98  4.98]
#>  [ 4.99  4.99  4.99 ...  4.99  4.99  4.99]]

# 计算sqrt(x**2 + y**2)
z = np.sqrt(x**2 + y**2)

# 可视化z
plt.imshow(z, cmap=plt.cm.rainbow); plt.colorbar()
plt.show()
```

# 2.　数学和统计方法

- `sum`：对数组中全部或某个轴向的元素求和，零长度的数组sum为０。
- `mean`：算术平均数，零长度数组的mean为NaN。
- `std`, `var`：标准差和方差。
- `min`, `max`：最小值和最大值。
- `argmin`, `argmax`：最小值和最大值的索引。
- `cumsum`：所有元素的累积和。
- `cumprod`：所有元素的累积积。

其中`sum`, `mean`等函数可以接收一个`axis`参数，用于计算该轴向上的统计值，最终结果会是少一维的数组，而`cumsum`和`cumprod`之类的累积计算方法不会聚合（不会降维），而是产生一个由中间结果组成的数组。

```python
import numpy as np

arr = np.random.randn(5, 4)
print(arr)
#> array([[ 8.03763296e-01, -2.03932135e-01, -5.32705457e-01,
#>         1.93629259e-01],
#>        [ 8.48828644e-01, -2.48243159e-01,  3.52948339e-01,
#>         -1.93479918e-01],
#>        [-1.67966138e-01, -1.39967085e-02, -4.09967656e-03,
#>         -4.27169326e-04],
#>        [-1.35807754e+00, -4.49490764e-01, -2.65211122e-01,
#>          2.10183618e-01],
#>        [-3.53980258e-01, -4.60741684e-01,  1.22120103e-01,
#>         -7.78639431e-03]])

arr.mean()
arr.mean(axis=1)
#> 0.05434106520071795
#> array([ 0.69968228, -0.35339797,  0.07811579, -0.30739759,  0.15470281])

arr.sum()
arr.sum(axis=1) #或者arr.sum(1)
#> 1.086821304014359
#> array([ 2.79872914, -1.41359189,  0.31246316, -1.22959036,  0.61881125])

arr.cumsum(0)
#> array([[ 0.8037633 , -0.25372163,  2.61217025, -0.36348278],
#>        [ 1.65259194, -0.54617543,  1.19038549, -0.91166475],
#>        [ 1.4846258 , -0.46284489,  1.4832884 , -0.80746889],
#>        [ 0.12654827, -0.13186912,  2.07331414, -1.59998323],
#>        [-0.22743199,  1.16973365,  1.80826301, -1.66374337]])

arr.cumprod(1)
#> array([[ 8.03763296e-01, -2.03932135e-01, -5.32705457e-01,
#>          1.93629259e-01],
#>        [ 8.48828644e-01, -2.48243159e-01,  3.52948339e-01,
#>         -1.93479918e-01],
#>        [-1.67966138e-01, -1.39967085e-02, -4.09967656e-03,
#>         -4.27169326e-04],
#>        [-1.35807754e+00, -4.49490764e-01, -2.65211122e-01,
#>          2.10183618e-01],
#>        [-3.53980258e-01, -4.60741684e-01,  1.22120103e-01,
#>         -7.78639431e-03]])
```

# 3. 用于布尔型数组的方法

通常在算术运算时，布尔值会被强制转换成1和0。因此`sum`可用来统计True的个数。

另外`any`和`all`两个方法也非常有用。`any`判断数组中有一个或多个True，`all`判断数组是否全部是True。

这两个方法也能用于非布尔值的数组，所有非0元素都被当成True。

```python
arr = np.array([True, False, True, False])

np.sum(arr)
#> 2

arr.all()
#> False

arr.any()
#> True
```

# 4. 排序

`sort`方法

```python
arr = np.array([-1, 5, 2, 0, -3])
arr.sort()
arr
#> array([-3, -1,  0,  2,  5])

arr = np.array([-1, 5, 2, 0, -3])
np.sort(arr)
#> array([-3, -1,  0,  2,  5])

arr
#> array([-1, 5, 2, 0, -3])
```
可以看到，第一种方法会改变原数组序列，而第二种方法会复制数组。

# 5. 唯一化以及其他集合逻辑

- `unique(x)`：找出数组中唯一值，并返回排序结果。其中`x`可以是多维数组，`unique`返回的是一维数组。

- `intersect1d(x, y)`：找出`x`, `y`中的公共元素，返回有序结果

- `union1d(x, y)`：　计算`x`, `y`并集，返回有序结果。

- `in1d(x, y)`：得到一个表示“x的元素是否包含于y”的布尔型数组。
- `setdiff1d(x, y)`：差集。
- `setxor1d`：对称差，即只存在与其中一个数组的元素。

```python
import numpy as np

x = np.array([1, 1, 2, 3, 4, 5])
y = np.array([3, 4, 5, 5, 6, 7])

np.unique(x)
#> array([1, 2, 3, 4, 5])

np.intersect1d(x, y)
#> array([3, 4, 5])

np.union1d(x, y)
#> array([1, 2, 3, 4, 5, 6, 7])

np.in1d(x, y)
#> array([False, False, False,  True,  True,  True])

np.setdiff1d(x, y)
#> array([1, 2])

np.setxor1d(x, y)
#> array([1, 2, 6, 7])
```
